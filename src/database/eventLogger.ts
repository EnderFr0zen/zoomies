import type { EventDocument, EventType, EventData, EventBuffer } from './types'
import { zoomiesDB } from './couchdb-simple'

// Event Logger Class
export class EventLogger {
  private buffer: EventBuffer
  private flushTimer: number | null = null
  private isFlushing = false
  private currentSessionId: string | null = null

  constructor() {
    this.buffer = {
      events: [],
      lastFlush: Date.now(),
      maxBufferSize: 50, // Maximum buffer event count
      flushInterval: 5000 // 5 second flush interval
    }

    // Set force flush when page is hidden
    this.setupPageHideHandler()
  }

  // Set page hidden handler
  private setupPageHideHandler(): void {
    const handlePageHide = () => {
      this.flushBuffer()
    }

    const handleBeforeUnload = () => {
      this.flushBuffer()
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        handlePageHide()
      }
    })

    window.addEventListener('beforeunload', handleBeforeUnload)
    window.addEventListener('pagehide', handlePageHide)
  }

  // Set current session ID
  setCurrentSession(sessionId: string): void {
    this.currentSessionId = sessionId
  }

  // Log event
  async logEvent(
    eventType: EventType, 
    data: EventData, 
    confidence?: number
  ): Promise<void> {
    if (!this.currentSessionId) {
      console.warn('No active session, event not logged:', eventType)
      return
    }

    const event: EventDocument = {
      _id: '', // Will be generated by database
      schemaVersion: 1,
      type: 'event',
      sessionId: this.currentSessionId,
      userId: 'default-user', // Temporary user ID, should be obtained from authentication system in actual application
      eventType,
      timestamp: new Date().toISOString(),
      data,
      confidence,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }

    // Add to buffer
    this.buffer.events.push(event)

    // Check if flush is needed
    if (this.buffer.events.length >= this.buffer.maxBufferSize) {
      await this.flushBuffer()
    } else if (!this.flushTimer) {
      this.scheduleFlush()
    }
  }

  // Log attention event
  async logAttentionPresent(attentionLevel: number, confidence?: number): Promise<void> {
    await this.logEvent('attention:present', {
      attentionLevel,
      reason: 'input_idle'
    }, confidence)
  }

  async logAttentionLost(reason: 'no_face' | 'yaw' | 'pitch' | 'tab_hidden' | 'input_idle' | 'window_blur'): Promise<void> {
    await this.logEvent('attention:lost', {
      reason
    })
  }

  // Log reminder event
  async logNudgeShown(nudgeType: 'nudge1' | 'nudge2', soundPlayed = false): Promise<void> {
    const eventType = nudgeType === 'nudge1' ? 'nudge1:shown' : 'nudge2:shown'
    await this.logEvent(eventType, {
      nudgeType,
      soundPlayed
    })

    if (soundPlayed) {
      await this.logEvent('nudge:sound_played', {
        nudgeType
      })
    }
  }

  // Log recovery event
  async logFocusRegained(responseTime?: number): Promise<void> {
    await this.logEvent('focus:regained', {
      metadata: { responseTime }
    })
  }

  // Log session event
  async logSessionStart(subject: string, duration?: number): Promise<void> {
    await this.logEvent('session:start', {
      subject,
      duration
    })
  }

  async logSessionEnd(subject: string, duration: number): Promise<void> {
    await this.logEvent('session:end', {
      subject,
      duration
    })
  }

  // Log koala interaction event
  async logKoalaInteraction(interactionType: 'dragged' | 'clicked', position?: { x: number; y: number }): Promise<void> {
    await this.logEvent('koala:dragged', {
      metadata: {
        interactionType,
        position
      }
    })
  }

  // Log settings change event
  async logSettingsChanged(settingName: string, settingValue: any): Promise<void> {
    await this.logEvent('settings:changed', {
      settingName,
      settingValue
    })
  }

  // Schedule flush
  private scheduleFlush(): void {
    if (this.flushTimer) return

    this.flushTimer = window.setTimeout(async () => {
      await this.flushBuffer()
    }, this.buffer.flushInterval)
  }

  // Flush buffer
  async flushBuffer(): Promise<void> {
    if (this.isFlushing || this.buffer.events.length === 0) return

    this.isFlushing = true

    try {
      // Clear timer
      if (this.flushTimer) {
        clearTimeout(this.flushTimer)
        this.flushTimer = null
      }

      // Batch write events
      const eventsToFlush = [...this.buffer.events]
      this.buffer.events = []

      for (const event of eventsToFlush) {
        try {
          await zoomiesDB.createEvent(event)
        } catch (error) {
          console.error('Failed to log event:', error, event)
          // Re-add to buffer for retry
          this.buffer.events.push(event)
        }
      }

      this.buffer.lastFlush = Date.now()
      console.log(`Flushed ${eventsToFlush.length} events to database`)

    } catch (error) {
      console.error('Failed to flush event buffer:', error)
    } finally {
      this.isFlushing = false
    }
  }

  // Force flush
  async forceFlush(): Promise<void> {
    await this.flushBuffer()
  }

  // Get buffer status
  getBufferStatus(): {
    eventCount: number
    lastFlush: number
    isFlushing: boolean
  } {
    return {
      eventCount: this.buffer.events.length,
      lastFlush: this.buffer.lastFlush,
      isFlushing: this.isFlushing
    }
  }

  // Clear buffer
  clearBuffer(): void {
    this.buffer.events = []
    if (this.flushTimer) {
      clearTimeout(this.flushTimer)
      this.flushTimer = null
    }
  }
}

// Export singleton instance
export const eventLogger = new EventLogger()
export default eventLogger
